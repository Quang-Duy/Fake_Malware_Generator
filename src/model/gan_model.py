""" Create GAN gan_model and its components

Usage

>>> python -m src.gan_model.gan_model

"""

import os

import hydra
import numpy as np
import omegaconf
import tensorflow
from omegaconf import DictConfig
from tensorflow.keras.layers import (BatchNormalization, Dense, Flatten, Input,
                                     LeakyReLU, Reshape)
from tensorflow.keras.models import Model, Sequential
from tensorflow.keras.optimizers import Adam

from src.common.utils import PROJECT_ROOT

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
tensorflow.compat.v1.logging.set_verbosity(tensorflow.compat.v1.logging.ERROR)
os.chdir(PROJECT_ROOT)


class GANModel:
    def __init__(self, model: DictConfig,
                 discriminator_param: DictConfig,
                 generator_param: DictConfig,
                 datamodule: DictConfig,
                 num_unique_opcode: int) -> None:
        self.latent_dim = model.latent_dim
        self.sample_shape = (datamodule.datasets.train.max_file_len,)

        optimizerD = Adam(learning_rate=model.lr, beta_1=model.beta_1)
        optimizerG = Adam(learning_rate=model.lr, beta_1=model.beta_1)

        # === Build Discriminator === #
        self.discriminator = self.build_discriminator(discriminator_param)
        self.discriminator.compile(loss=discriminator_param.loss,
                                   optimizer=optimizerD,
                                   metrics=discriminator_param.metrics)

        # === Build Generator ===#
        self.generator = self.build_generator(generator_param)

        # Create noise vectors as input for generator
        z = Input(shape=(self.latent_dim,))
        random_input = self.generator(z)

        # We don't train Discriminator in the network
        self.discriminator.trainable = False

        # Discriminator takes generated input as input and determines validity
        validity = self.discriminator(random_input)

        # === Network (aka combined G and D) === #
        self.network = Model(z, validity)
        self.network.compile(loss=generator_param.loss,
                             optimizer=optimizerG,
                             metrics=generator_param.metrics)

    def build_generator(self, generator_param):
        def build_block(model: Sequential,
                        output: int,
                        alpha: float,
                        momentum: float,
                        input_dim: int = None) -> None:
            if input_dim:
                model.add(Dense(int(output), input_dim=self.latent_dim))
            else:
                model.add(Dense(int(output)))

            model.add(LeakyReLU(alpha=alpha))
            model.add(BatchNormalization(momentum=momentum))

        model = Sequential()
        build_block(model=model, output=generator_param.first_output,
                    alpha=generator_param.alpha,
                    momentum=generator_param.momentum,
                    input_dim=self.latent_dim)

        build_block(model=model, output=generator_param.first_output * 2,
                    alpha=generator_param.alpha,
                    momentum=generator_param.momentum)

        build_block(model=model, output=generator_param.first_output * 4,
                    alpha=generator_param.alpha,
                    momentum=generator_param.momentum)

        model.add(Dense(np.prod(self.sample_shape),
                        activation=generator_param.activation))
        model.add(Reshape(self.sample_shape))

        noise = Input(shape=(self.latent_dim,))
        img = model(noise)

        return Model(noise, img)

    def build_discriminator(self, discriminator_param: DictConfig):
        def build_block(model: Sequential, output: int, alpha: float) -> None:
            model.add(Dense(int(output)))
            model.add(LeakyReLU(alpha=alpha))

        model = Sequential()
        model.add(Flatten(input_shape=self.sample_shape))

        build_block(model=model, output=discriminator_param.first_output,
                    alpha=discriminator_param.alpha)

        build_block(model=model, output=discriminator_param.first_output / 2,
                    alpha=discriminator_param.alpha)

        model.add(Dense(discriminator_param.last_output,
                        activation=discriminator_param.activation))

        img = Input(shape=self.sample_shape)
        validity = model(img)

        return Model(img, validity)

    @staticmethod
    def smooth_positive_labels(labels):
        alpha = np.random.uniform(0, 1, labels.shape)
        labels = labels - 0.3 + (alpha * 0.5)
        return labels

    def save_model(self, save_path, file_name):
        if not os.path.exists(save_path):
            os.mkdir(save_path)
        path = os.path.join(save_path, file_name)
        self.generator.save(path, include_optimizer=True, save_format='h5')


@hydra.main(config_path=str(PROJECT_ROOT / 'conf'), config_name='default')
def main(cfg: omegaconf.DictConfig):
    model = hydra.utils.instantiate(
        cfg.model.modelmodule,
        datamodule=cfg.data.datamodule,
        num_unique_opcode=21,
        _recursive_=False
    )
    print("Success!") if model else print("Fail!")


if __name__ == "__main__":
    main()
